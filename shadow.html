<!DOCTYPE html>
<html>
	<head>
		<title>Shadow Mesh</title>
		<link rel="stylesheet" type="text/css" href="css\styles.css">
	</head>
	<body class="gamepage">
		<header>
			<nav>
			<ul class="navigation">
				<li><a href="#home">Home</a></li>
				<div class="dropdown">
					<button class="dropbtn nav-link"><a href="#projects">Stuff I've Made</a>
						<i class="fa fa-caret-down"></i>
					</button>
					<div class="dropdown-content">
						<a href="hookfoot.html" class="nav-link">Captain Hookfoot</a>
						<a href="visvi.html" class="nav-link">Visvi</a>
						<a href="wormgame.html" class="nav-link">Funny Worm Game</a>
						<a href="bearswithguns.html" class="nav-link">Bears with Guns</a>
						<a href="eden.html" class="nav-link">EDEN</a>
						<a href="thrillertheater.html" class="nav-link">Thriller Theater</a>
						<a href="shadow.html" class="nav-link">Shadow Mesh Generator</a>
						<a href="graphics.html" class="nav-link">Graphics Programming</a>
					</div>
				</div>
				<li><a href="#contact">Contact</a></li>
				<li><a href="Demetrius Nekos Resume.pdf">Resume</a></li>
			</ul>
			<button class="burger-menu" id="burger-menu">
				<ion-icon class="bars" name="menu-outline"></ion-icon>
			</button>
		</nav>
		</header>
		<main>
			<div class="wrapper">
				<div class="left">
					<div class="info">
						<h1>Shadow Mesh Generation</h1>
						<p>This is a technical test that I am currently working on in Unity. I started it for a Creators Jam in the winter of 2021 and have since updated it to work better and faster. It uses a marching squares algorithm to contour the shadow off of a surface with raycasts and uses tyhat to create an interactable mesh. I have recently added multithreading to the triangulation marching squares algorithm, reducing the time to generate a mesh from ~0.9314 seconds to only ~0.127</p>
					</div>
					<div class="info">
						<h2>Features/Things I built:</h2>
						<ul class="work-done">
							<li>Raycasting</li>
							<li>Mesh Generation</li>
							<li>Marching Squares Algorithm</a></li>
							<li>Multithreading</li>
						</ul>
					</div>
				</div>
				<div class="right">
					<p class="itch">
						<iframe width="560" height="315" src="https://www.youtube.com/embed/ZQM0orXiMcA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
					</p>
				</div>
			</div>
			<div class="wrapper">
				<div class="left">
					<div class="info">
						<h2>Shadow detection and Marching Squares</h1>
						<p>The system first starts by sending a ray out from the camera to a point on the surface its facing. Using the normal vector from the point the raycast hits, the function creates a 2D grid of points and checks each of them to see if they are shadowed. It accomplished that using simple raycasts to any nearby light sources. Next, once each of the points have been given values, they are triangulated using the Marching Squares algorithm. In addition to the current square, points are also created and given triangles for the opposite face and any side squares, if on the edge. Once all the points have been triangulated, those points are put together into a mesh to create the shadow, which can then be instantiated</p>
					</div>
				</div>
				<div class="right">
					
				</div>
			</div>
			<div class="wrapper">
				<div class="left">
					<div class="info">
						<h2>Optimizing and Multithreading</h1>
						<p>The primary issue with the system as it was first built is how long it takes to create the mesh. It wouldn't be suitable as a game mechanic if there was a full second wait each time. After some testing I determined the two largest time sinks. The first was node creation, as it used both raycasts to each light, as well as an expensive physics function to see if the point is actually on the surface, as well as some inefficient looping creating unneccisary function calls. The second and bigger issue was the actual triangulation, due to how many points that were needed to be calculated. I was able to optimize the looping for the first issue, but couldn't take out the expensive calls. I could, however, reduce lag by implementing multithreading. After playing with rudimentary threads, I settles on using Unity's Job system, which allowed me to move almost all of the triangulation calculations out of the main thread. Doing so increased performance sevenfold, with the game handling much more smoothly.</p>
					</div>
				</div>
				<div class="right">
					
				</div>
			</div>
		</main>
	</body>
</html>